Index: app/routers/auth.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nimport logging\r\nfrom datetime import datetime\r\nimport pytz\r\nfrom bson import ObjectId\r\nfrom fastapi import APIRouter, Request, HTTPException, status, Response, Depends\r\nfrom fastapi.responses import JSONResponse\r\nfrom app.schemas.user_schemas import UserCreate\r\nfrom app.schemas.auth_schemas import AuthRequest, TokenResponse\r\nfrom app.db.database import db\r\nfrom app.core.security import (\r\n    hash_password,\r\n    verify_password,\r\n    create_access_token,\r\n    store_token_in_db\r\n)\r\nfrom app.core.config import settings\r\nfrom fastapi.security import HTTPBearer\r\nfrom app.schemas.admin_schemas import AdminToken\r\nfrom app.admin.telegram_2fa import send_2fa_request\r\nfrom app.admin.utils import create_token, get_ip, get_user_agent\r\n\r\nrouter = APIRouter()\r\nlogger = logging.getLogger(__name__)\r\nsecurity = HTTPBearer()\r\n# -------------------------\r\n# RATE LIMIT (упрощённо)\r\n# -------------------------\r\nMAX_ATTEMPTS = 5\r\nWINDOW_SECONDS = 300\r\nlogin_attempts = {}\r\n\r\ndef check_rate_limit(ip: str) -> bool:\r\n    now = time.time()\r\n    if ip not in login_attempts:\r\n        login_attempts[ip] = []\r\n    # Оставляем только недавние попытки (в пределах WINDOW_SECONDS)\r\n    login_attempts[ip] = [t for t in login_attempts[ip] if (now - t) <= WINDOW_SECONDS]\r\n    return len(login_attempts[ip]) < MAX_ATTEMPTS\r\n\r\ndef register_attempt(ip: str):\r\n    now = time.time()\r\n    if ip not in login_attempts:\r\n        login_attempts[ip] = []\r\n    login_attempts[ip].append(now)\r\n\r\n\r\ndef get_ip(request: Request) -> str:\r\n    return request.client.host or \"unknown\"\r\n\r\ndef get_user_agent(request: Request) -> str:\r\n    return request.headers.get(\"User-Agent\", \"unknown\")\r\n\r\ndef sanitize_input(value: str) -> str:\r\n    if any(c in value for c in ['$', '{', '}', '<', '>']):\r\n        raise ValueError(\"Запрещённые символы во входе\")\r\n    return value.strip()\r\n\r\n\r\n# -------------------------\r\n# LOGIN\r\n# -------------------------\r\n@router.post(\"/login\")\r\nasync def unified_login(data: AuthRequest, request: Request):\r\n    ip = get_ip(request)\r\n    ua = get_user_agent(request)\r\n    now = datetime.utcnow()\r\n\r\n    try:\r\n        ident = sanitize_input(data.username)\r\n    except ValueError:\r\n        raise HTTPException(status_code=400, detail=\"Ввод содержит запрещённые символы\")\r\n\r\n    # if not check_rate_limit(ip):\r\n    #     raise HTTPException(status_code=status.HTTP_429_TOO_MANY_REQUESTS,\r\n    #                         detail=\"Too many login attempts. Please wait before retrying.\")\r\n\r\n    admin = await db.admins.find_one({\"$or\": [{\"email\": ident}, {\"iin\": ident}]})\r\n    if admin:\r\n        if not verify_password(data.password, admin[\"hashed_password\"]):\r\n            await db.login_logs.insert_one({\"ident\": ident, \"timestamp\": now, \"success\": False})\r\n            raise HTTPException(status_code=401, detail=\"Неверные данные (admin)\")\r\n\r\n        if admin.get(\"active_session\") and (\r\n                admin[\"active_session\"].get(\"ip\") != ip or\r\n                admin[\"active_session\"].get(\"user_agent\") != ua):\r\n            await db.admins.update_one({\"_id\": admin[\"_id\"]}, {\"$set\": {\"is_verified\": False}})\r\n            await send_2fa_request(admin, ip, ua)\r\n            raise HTTPException(status_code=403, detail=\"Подтвердите вход в Telegram\")\r\n\r\n        token = create_token({\"sub\": str(admin[\"_id\"]), \"role\": admin[\"role\"]})\r\n\r\n        await db.admins.update_one({\"_id\": admin[\"_id\"]}, {\"$set\": {\r\n            \"active_session\": {\"ip\": ip, \"user_agent\": ua, \"token\": token},\r\n            \"last_login\": {\"timestamp\": now, \"ip\": ip, \"user_agent\": ua},\r\n            \"is_verified\": True\r\n        }})\r\n\r\n        await db.login_logs.insert_one({\"ident\": ident, \"timestamp\": now, \"success\": True})\r\n\r\n        response = JSONResponse(content={\r\n            \"access_token\": token,\r\n            \"token_type\": \"bearer\"\r\n        })\r\n        return response\r\n\r\n    user = await db.users.find_one({\r\n        \"$or\": [\r\n            {\"iin\": ident},\r\n            {\"email\": ident.lower()}\r\n        ]\r\n    })\r\n\r\n    if not user:\r\n        # register_attempt(ip)\r\n        raise HTTPException(status_code=400, detail=\"Incorrect username or password\")\r\n\r\n    if not verify_password(data.password, user[\"hashed_password\"]):\r\n#         register_attempt(ip)\r\n        raise HTTPException(status_code=400, detail=\"Incorrect username or password\")\r\n\r\n#     register_attempt(ip)\r\n\r\n    token_data = {\r\n        \"sub\": str(user[\"_id\"]),\r\n        \"role\": user.get(\"role\", \"user\")\r\n    }\r\n    access_token, expires_at = create_access_token(token_data)\r\n\r\n    await store_token_in_db(access_token, user[\"_id\"], expires_at, ip, ua)\r\n\r\n    response = JSONResponse(content={\r\n        \"access_token\": access_token,\r\n        \"token_type\": \"bearer\"\r\n    })\r\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\r\n\r\n\r\n\r\n# -------------------------\r\n# REGISTER\r\n# -------------------------\r\n@router.post(\"/register\", response_model=TokenResponse)\r\nasync def register_user(user_data: UserCreate, request: Request):\r\n    ip = request.client.host\r\n\r\n    if not check_rate_limit(ip):\r\n        raise HTTPException(\r\n            status_code=status.HTTP_429_TOO_MANY_REQUESTS,\r\n            detail=\"Слишком много попыток регистрации. Попробуйте позже.\"\r\n        )\r\n    register_attempt(ip)\r\n\r\n    if user_data.password != user_data.confirm_password:\r\n        raise HTTPException(status_code=400, detail=\"Пароли не совпадают\")\r\n\r\n    existing_user = await db.users.find_one({\r\n        \"$or\": [\r\n            {\"iin\": user_data.iin},\r\n            {\"email\": user_data.email.lower()},\r\n            {\"phone\": user_data.phone}\r\n        ]\r\n    })\r\n    if existing_user:\r\n        raise HTTPException(status_code=400, detail=\"Пользователь с таким ИИН, Email или телефоном уже существует\")\r\n\r\n    hashed_pw = hash_password(user_data.password)\r\n\r\n    new_user = {\r\n        \"iin\": user_data.iin,\r\n        \"phone\": user_data.phone,\r\n        \"email\": user_data.email.lower(),\r\n        \"hashed_password\": hashed_pw,\r\n        \"role\": \"user\",\r\n        \"created_at\": datetime.utcnow()\r\n    }\r\n    result = await db.users.insert_one(new_user)\r\n    user_id = result.inserted_id\r\n\r\n    logger.info(f\"Регистрация нового пользователя: {user_data.email} (ID: {user_id})\")\r\n\r\n    # Генерируем JWT + узнаём время истечения\r\n    token_data = {\r\n        \"sub\": str(user_id),\r\n        \"role\": \"user\"\r\n    }\r\n    access_token, expires_at = create_access_token(token_data)\r\n\r\n    # Сохраняем в MongoDB (коллекция tokens)\r\n    user_agent = request.headers.get(\"User-Agent\", \"unknown\")\r\n    await store_token_in_db(access_token, user_id, expires_at, ip, user_agent)\r\n\r\n    response = JSONResponse(content={\r\n        \"access_token\": access_token,\r\n        \"token_type\": \"bearer\"\r\n    })\r\n    return response\r\n\r\n\r\n# -------------------------\r\n# LOGOUT (Отзыв токена)\r\n# -------------------------\r\n@router.post(\"/logout\")\r\nasync def logout_user(request: Request, credentials=Depends(security)):\r\n    token = credentials.credentials\r\n    payload = decode_token(token)\r\n    user_id = payload.get(\"sub\")\r\n    role = payload.get(\"role\")\r\n\r\n    # Проверка допустимых ролей\r\n    if role not in [\"user\", \"admin\", \"moderator\", \"manager\", \"super_admin\"]:\r\n        raise HTTPException(status_code=403, detail=\"Недопустимая роль\")\r\n\r\n    # Логирование выхода\r\n    logger.info(f\"[LOGOUT] role={role} user_id={user_id} ip={request.client.host}\")\r\n\r\n    if role == \"user\":\r\n        token_doc = await db.tokens.find_one({\"token\": token})\r\n        if not token_doc:\r\n            raise HTTPException(status_code=400, detail=\"Token not found or already invalid\")\r\n\r\n        await db.tokens.update_one(\r\n            {\"_id\": token_doc[\"_id\"]},\r\n            {\"$set\": {\"revoked\": True}}\r\n        )\r\n        return {\"detail\": \"Token has been revoked\"}\r\n    else:\r\n        admin = await db.admins.find_one({\"_id\": ObjectId(user_id)})\r\n        if not admin:\r\n            raise HTTPException(status_code=404, detail=\"Админ не найден\")\r\n\r\n        await db.admins.update_one({\"_id\": ObjectId(user_id)}, {\"$set\": {\"active_session\": None}})\r\n        return {\"detail\": f\"Session closed for role: {role}\"}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/routers/auth.py b/app/routers/auth.py
--- a/app/routers/auth.py	(revision 373642d0d6e2635a759d5d278fa8a570eb1427b0)
+++ b/app/routers/auth.py	(date 1743883966808)
@@ -71,9 +71,9 @@
     except ValueError:
         raise HTTPException(status_code=400, detail="Ввод содержит запрещённые символы")
 
-    # if not check_rate_limit(ip):
-    #     raise HTTPException(status_code=status.HTTP_429_TOO_MANY_REQUESTS,
-    #                         detail="Too many login attempts. Please wait before retrying.")
+    if not check_rate_limit(ip):
+        raise HTTPException(status_code=status.HTTP_429_TOO_MANY_REQUESTS,
+                            detail="Too many login attempts. Please wait before retrying.")
 
     admin = await db.admins.find_one({"$or": [{"email": ident}, {"iin": ident}]})
     if admin:
@@ -112,14 +112,14 @@
     })
 
     if not user:
-        # register_attempt(ip)
+        register_attempt(ip)
         raise HTTPException(status_code=400, detail="Incorrect username or password")
 
     if not verify_password(data.password, user["hashed_password"]):
-#         register_attempt(ip)
+        register_attempt(ip)
         raise HTTPException(status_code=400, detail="Incorrect username or password")
 
-#     register_attempt(ip)
+    register_attempt(ip)
 
     token_data = {
         "sub": str(user["_id"]),
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># app/main.py\r\n\r\nimport logging\r\nimport asyncio\r\nfrom fastapi import FastAPI\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\nfrom app.core.logging_config import setup_logging\r\nfrom app.core.config import settings\r\nfrom app.routers import auth, user, reset_password, admin_router, test_router, subscription_router\r\nfrom aiogram import Dispatcher\r\nfrom app.admin.telegram_2fa import bot, router as telegram_router\r\nfrom fastapi.staticfiles import StaticFiles\r\n\r\n# Инициализация логирования\r\nsetup_logging()\r\nlogger = logging.getLogger(__name__)\r\n\r\n# Создаём приложение\r\napp = FastAPI(\r\n    title=\"Royal_api!\",\r\n    description=\"TI KTO VAHE1?\",\r\n    version=\"1.0.0\"\r\n)\r\n\r\n# CORS (для доступа с фронта)\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=[\r\n        \"http://localhost:3000\",\r\n        \"http://127.0.0.1:3000\",\r\n    ],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n# Подключаем роутеры\r\napp.include_router(auth.router, prefix=\"/auth\", tags=[\"auth\"])\r\napp.include_router(user.router, prefix=\"/users\", tags=[\"users\"])\r\napp.include_router(reset_password.router, prefix=\"/reset\", tags=[\"reset-password\"])\r\napp.include_router(admin_router.router)\r\napp.include_router(test_router.router, prefix=\"/tests\", tags=[\"tests\"])\r\napp.include_router(subscription_router.router, prefix=\"/subscriptions\", tags=[\"subscriptions\"])\r\n\r\napp.mount(\"/\", StaticFiles(directory=\"html_testing\", html=True), name=\"static\")\r\n\r\n# Пример простого эндпоинта\r\n@app.get(\"/\")\r\ndef root():\r\n    logger.info(\"Root endpoint called.\")\r\n    return {\"message\": \"Hello from Pizdes!\"}\r\n\r\n# Запуск Telegram-бота через polling\r\nasync def start_bot():\r\n    dp = Dispatcher()\r\n    dp.include_router(telegram_router)\r\n    await dp.start_polling(bot)\r\n\r\n@app.on_event(\"startup\")\r\nasync def startup_event():\r\n    asyncio.create_task(start_bot())
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 373642d0d6e2635a759d5d278fa8a570eb1427b0)
+++ b/main.py	(date 1743883765159)
@@ -25,10 +25,7 @@
 # CORS (для доступа с фронта)
 app.add_middleware(
     CORSMiddleware,
-    allow_origins=[
-        "http://localhost:3000",
-        "http://127.0.0.1:3000",
-    ],
+    allow_origins=["*"],
     allow_credentials=True,
     allow_methods=["*"],
     allow_headers=["*"],
@@ -42,7 +39,7 @@
 app.include_router(test_router.router, prefix="/tests", tags=["tests"])
 app.include_router(subscription_router.router, prefix="/subscriptions", tags=["subscriptions"])
 
-app.mount("/", StaticFiles(directory="html_testing", html=True), name="static")
+# app.mount("/", StaticFiles(directory="html_testing", html=True), name="static")
 
 # Пример простого эндпоинта
 @app.get("/")
